{"version":3,"file":"index.cjs","sources":["../src/regexUtil/index.ts","../src/stringUtil/index.ts","../src/envUtil/index.ts","../src/objectUtil/index.ts"],"sourcesContent":["export const getType = <T>(obj: T): string => (Object.prototype.toString.call(obj)).match(/\\w+\\s(\\w+)/)![1].toLowerCase();\n","import { getType } from \"../regexUtil\";\n\nexport const capitalizeFirstWordInSentence = (sentence: string | any): string | any => {\n    if (typeof sentence === 'string' || sentence instanceof String) {\n        if (sentence.trim().length) {\n            const phraseFromSentence = sentence.split('. ');\n            return phraseFromSentence.map((phrase) => phrase.charAt(0).toUpperCase() + phrase.slice(1)).join('. ');\n        }\n        return '';\n    }\n    return sentence;\n};\n\nexport const isNonEmptyString = (anyData: any): boolean => typeof anyData === 'string' && anyData.trim() !== '';\n\nexport const isSameText = (\n    firstText: string,\n    secondText: string,\n    caseInsensitive = true\n) => {\n    if (getType(firstText) === 'string' && getType(firstText) === 'string') {\n        if (caseInsensitive) {\n            return firstText.toLowerCase() === secondText.toLowerCase();\n        }\n        return firstText === secondText;\n    }\n    return false;\n};\n","export const isTestEnv = process.env['NODE_DEV'] = 'TEST';","/* eslint-disable no-restricted-syntax */\nimport { isTestEnv } from '../envUtil';\nimport { getType } from '../regexUtil';\nimport { isSameText } from '../stringUtil';\n\nconst isObject = <T>(obj: T) => getType(obj) === 'object';\n\nconst circularReplacer = () => {\n    const seen = new WeakSet();\n    return (key: string, value: any) => {\n        if (typeof value === 'object' && value !== null) {\n            if (seen.has(value)) {\n                return;\n            }\n            seen.add(value);\n        }\n        return value;\n    };\n};\n\nexport const deepCloneWithoutCircularReferences = <T>(obj: T) => JSON.parse(JSON.stringify(obj, circularReplacer()));\n\ntype CacheItem = {\n    original: any,\n    copy: any\n}\n\n// backward compatible deep copy, circular references allowed\nconst newCopyHelper = <T>(obj: T) => Array.isArray(obj) ? new Array() : Object.assign({});\n\nexport const recursiveDeepClone = <T>(obj: T, cacheList: CacheItem[] = []): T => {\n    const inputType = getType(obj)\n    // just return if obj is immutable value\n    if (['object', 'array'].indexOf(inputType) === -1) {\n        return obj;\n    }\n\n    // if obj is hit, it is in circular structure\n    const circularStructure = cacheList.find((c) => c.original === obj);\n    if (circularStructure) {\n        return circularStructure.copy;\n    }\n\n    const copy = newCopyHelper(obj);\n    // put the copy into cache at first\n    // because we want to refer it in recursive deep copy\n    cacheList.push({ original: obj, copy });\n\n    Object.keys(obj as [] | Record<string, any>).forEach((key) => {\n        const idx = parseInt(key)\n        if (Number.isNaN(idx)) {\n            copy[key] = recursiveDeepClone((obj as Record<string, any>)[key], cacheList);\n        } else {\n            copy[key] = recursiveDeepClone((obj as [])[idx], cacheList);\n        }\n    });\n\n    return <T>copy;\n};\n\n// deep copy obj with circular references using JSON.parse(JSON.stringfy(obj)) will fail\n// this is the better way to handle that\nconst deepClone = <T>(obj: T) => {\n    try {\n        // https://developer.mozilla.org/en-US/docs/Web/API/structuredClone\n        return structuredClone(obj);\n    } catch {\n        // old browser or node env below v. 17 will not have structuredClone\n        return recursiveDeepClone(obj);\n    }\n};\n\nmodule.exports.isObject = isObject\nmodule.exports.deepClone = deepClone\nif (isTestEnv) {\n    module.exports.newCopyHelper = newCopyHelper\n}"],"names":["getType","obj","Object","prototype","toString","call","match","toLowerCase","sentence","String","trim","length","split","map","phrase","charAt","toUpperCase","slice","join","anyData","firstText","secondText","caseInsensitive","isTestEnv","process","env","Array","isArray","assign","cacheList","indexOf","inputType","find","c","original","circularStructure","copy","newCopyHelper","push","keys","forEach","key","idx","parseInt","Number","isNaN","recursiveDeepClone","module","exports","isObject","deepClone","structuredClone","_unused","parse","JSON","stringify","value","seen","has","add"],"mappings":"AAAaA,IAAAA,EAAU,SAAIC,GAAM,OAAoBC,OAACC,UAAUC,SAASC,KAAKJ,GAAMK,MAAM,cAAe,GAAGC,aAAa,+ECE5E,SAACC,GAC1C,MAAwB,iBAALA,GAAiBA,aAAoBC,OAChDD,EAASE,OAAOC,OACWH,EAASI,MAAM,MAChBC,IAAI,SAACC,UAAiBA,EAACC,OAAO,GAAGC,cAAgBF,EAAOG,MAAM,EAAE,GAAEC,KAAK,MAE9F,GAEJV,CACX,mBAEgC,SAACW,GAA0B,MAAmB,oBAA+B,KAAnBA,EAAQT,MAAa,aAErF,SACtBU,EACAC,EACAC,GAEA,gBAFAA,IAAAA,GAAkB,GAES,WAAvBtB,EAAQoB,IAAkD,WAAvBpB,EAAQoB,KACvCE,IACiBf,gBAAkBc,EAAWd,cAElCa,IAAKC,EAG7B,GC3BsBE,EAAGC,QAAQC,IAAc,SAAI,SC4B7B,SAAIxB,GAAWyB,OAAAA,MAAMC,QAAQ1B,GAAO,IAAIyB,MAAUxB,OAAO0B,OAAO,GAAG,IAEvD,WAAI3B,EAAQ4B,YAAAA,IAAAA,EAAyB,IACnE,MAAkB7B,EAAQC,GAE1B,IAAgD,IAA5C,CAAC,SAAU,SAAS6B,QAAQC,GAC5B,OAAO9B,EAIX,MAA0B4B,EAAUG,KAAK,SAACC,GAAMA,OAAAA,EAAEC,WAAajC,CAAG,GAClE,GAAIkC,EACA,SAAyBC,KAG7B,IAAMA,EAAOC,EAAcpC,GAc3B,OAXA4B,EAAUS,KAAK,CAAEJ,SAAUjC,EAAKmC,KAAAA,IAEhClC,OAAOqC,KAAKtC,GAAiCuC,QAAQ,SAACC,GAClD,IAAMC,EAAMC,SAASF,GAEjBL,EAAKK,GADLG,OAAOC,MAAMH,GACDI,EAAoB7C,EAA4BwC,GAAMZ,GAEtDiB,EAAoB7C,EAAWyC,GAAMb,EAEzD,IAGJ,EAcAkB,OAAOC,QAAQC,SAnEE,SAAIhD,SAA4B,WAAVD,EAACC,EAAiB,EAoEzD8C,OAAOC,QAAQE,UAXG,SAAIjD,GAClB,IAEI,OAAOkD,gBAAgBlD,EAI1B,CAHC,MAAMmD,GAEJ,OAAyBN,EAAC7C,EAC7B,CACL,EAIIsB,IACAwB,OAAOC,QAAQX,cAAgBA,yEAvDe,SAAIpC,GAAM,YAAUoD,MAAMC,KAAKC,UAAUtD,KAZ1E,qBACLwC,EAAae,GACjB,GAAqB,oBAAsB,OAAVA,EAAgB,CAC7C,GAAIC,EAAKC,IAAIF,GACT,OAEJC,EAAKE,IAAIH,EACZ,CACD,OACJA,CAAA,KAVqB,KAa2F"}